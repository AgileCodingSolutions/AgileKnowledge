//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthorizeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param account (optional) 
     * @param pass (optional) 
     * @return Success
     */
    token(account: string | undefined, pass: string | undefined): Promise<AuthorizeDto> {
        let url_ = this.baseUrl + "/api/Authorize/Token?";
        if (account === null)
            throw new Error("The parameter 'account' cannot be null.");
        else if (account !== undefined)
            url_ += "account=" + encodeURIComponent("" + account) + "&";
        if (pass === null)
            throw new Error("The parameter 'pass' cannot be null.");
        else if (pass !== undefined)
            url_ += "pass=" + encodeURIComponent("" + pass) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToken(_response);
        });
    }

    protected processToken(response: Response): Promise<AuthorizeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorizeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorizeDto>(null as any);
    }
}

export class ChatApplicationService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getList(filter: string | undefined, sorting: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<ChatApplicationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/ChatApplication/GetList?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<ChatApplicationDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatApplicationDtoPagedResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatApplicationDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Promise<ChatApplicationDto> {
        let url_ = this.baseUrl + "/api/ChatApplication/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ChatApplicationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatApplicationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatApplicationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateChatApplicationInputDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ChatApplication/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateChatApplicationInputDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ChatApplication/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ChatApplication/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createChatDialog(body: CreateChatDialogInputDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ChatApplication/CreateChatDialog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateChatDialog(_response);
        });
    }

    protected processCreateChatDialog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param applicationId (optional) 
     * @return Success
     */
    getChatDialog(applicationId: string | undefined): Promise<ChatDialogDto[]> {
        let url_ = this.baseUrl + "/api/ChatApplication/GetChatDialog?";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChatDialog(_response);
        });
    }

    protected processGetChatDialog(response: Response): Promise<ChatDialogDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatDialogDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatDialogDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createChatDialogHistory(body: CreateChatDialogHistoryInputDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ChatApplication/CreateChatDialogHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateChatDialogHistory(_response);
        });
    }

    protected processCreateChatDialogHistory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param chatApplicationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getPostShareList(chatApplicationId: string | undefined, filter: string | undefined, sorting: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<PostShareDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/ChatApplication/GetPostShareList?";
        if (chatApplicationId === null)
            throw new Error("The parameter 'chatApplicationId' cannot be null.");
        else if (chatApplicationId !== undefined)
            url_ += "ChatApplicationId=" + encodeURIComponent("" + chatApplicationId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPostShareList(_response);
        });
    }

    protected processGetPostShareList(response: Response): Promise<PostShareDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostShareDtoPagedResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostShareDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPostShare(body: CreatePostShareInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ChatApplication/CreatePostShare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePostShare(_response);
        });
    }

    protected processCreatePostShare(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteChatDialog(id: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/ChatApplication/DeleteChatDialog?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteChatDialog(_response);
        });
    }

    protected processDeleteChatDialog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param chatDialogId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getChatDialogHistory(chatDialogId: string | undefined, filter: string | undefined, sorting: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<CreateChatDialogHistoryInputDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/ChatApplication/GetChatDialogHistory?";
        if (chatDialogId === null)
            throw new Error("The parameter 'chatDialogId' cannot be null.");
        else if (chatDialogId !== undefined)
            url_ += "ChatDialogId=" + encodeURIComponent("" + chatDialogId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChatDialogHistory(_response);
        });
    }

    protected processGetChatDialogHistory(response: Response): Promise<CreateChatDialogHistoryInputDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateChatDialogHistoryInputDtoPagedResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateChatDialogHistoryInputDtoPagedResultDto>(null as any);
    }
}

export class FunctionService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFunction(body: FastWikiFunctionCallInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Function/CreateFunction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFunction(_response);
        });
    }

    protected processCreateFunction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class KnowledgeService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getList(filter: string | undefined, sorting: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<KnowledgeBasesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/Knowledge/GetList?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<KnowledgeBasesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeBasesDtoPagedResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KnowledgeBasesDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Promise<KnowledgeBasesDto> {
        let url_ = this.baseUrl + "/api/Knowledge/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<KnowledgeBasesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeBasesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KnowledgeBasesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateKnowledgeBasesInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateKnowledgeBasesInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDetails(body: CreateKnowledgeDetailsInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/CreateDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDetails(_response);
        });
    }

    protected processCreateDetails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDetails(id: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/DeleteDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDetails(_response);
        });
    }

    protected processDeleteDetails(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param knowledgeBaseId (optional) 
     * @param state (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getDetailsList(knowledgeBaseId: string | undefined, state: KnowledgeBaseQuantizationState | undefined, filter: string | undefined, sorting: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<KnowledgeBaseDetailsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/Knowledge/GetDetailsList?";
        if (knowledgeBaseId === null)
            throw new Error("The parameter 'knowledgeBaseId' cannot be null.");
        else if (knowledgeBaseId !== undefined)
            url_ += "KnowledgeBaseId=" + encodeURIComponent("" + knowledgeBaseId) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetailsList(_response);
        });
    }

    protected processGetDetailsList(response: Response): Promise<KnowledgeBaseDetailsDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeBaseDetailsDtoPagedResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KnowledgeBaseDetailsDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDetailVectorQuantity(body: KnowledgeBaseDetailsVectorQuantityInputDto | undefined): Promise<KnowledgeBaseDetailVectorQuantityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/Knowledge/GetDetailVectorQuantity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetailVectorQuantity(_response);
        });
    }

    protected processGetDetailVectorQuantity(response: Response): Promise<KnowledgeBaseDetailVectorQuantityDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KnowledgeBaseDetailVectorQuantityDtoPagedResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KnowledgeBaseDetailVectorQuantityDtoPagedResultDto>(null as any);
    }

    /**
     * @param documentId (optional) 
     * @return Success
     */
    deleteDetailVectorQuantity(documentId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/DeleteDetailVectorQuantity?";
        if (documentId === null)
            throw new Error("The parameter 'documentId' cannot be null.");
        else if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDetailVectorQuantity(_response);
        });
    }

    protected processDeleteDetailVectorQuantity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param wikiId (optional) 
     * @param search (optional) 
     * @param minRelevance (optional) 
     * @return Success
     */
    getSearchVectorQuantity(wikiId: string | undefined, search: string | undefined, minRelevance: number | undefined): Promise<SearchVectorQuantityDto> {
        let url_ = this.baseUrl + "/api/Knowledge/GetSearchVectorQuantity?";
        if (wikiId === null)
            throw new Error("The parameter 'wikiId' cannot be null.");
        else if (wikiId !== undefined)
            url_ += "wikiId=" + encodeURIComponent("" + wikiId) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (minRelevance === null)
            throw new Error("The parameter 'minRelevance' cannot be null.");
        else if (minRelevance !== undefined)
            url_ += "minRelevance=" + encodeURIComponent("" + minRelevance) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSearchVectorQuantity(_response);
        });
    }

    protected processGetSearchVectorQuantity(response: Response): Promise<SearchVectorQuantityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchVectorQuantityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchVectorQuantityDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDetailsVector(id: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/DeleteDetailsVector?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDetailsVector(_response);
        });
    }

    protected processDeleteDetailsVector(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param knowledgeBaseDetailsId (optional) 
     * @return Success
     */
    retryVectorDetail(knowledgeBaseDetailsId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/RetryVectorDetail?";
        if (knowledgeBaseDetailsId === null)
            throw new Error("The parameter 'knowledgeBaseDetailsId' cannot be null.");
        else if (knowledgeBaseDetailsId !== undefined)
            url_ += "knowledgeBaseDetailsId=" + encodeURIComponent("" + knowledgeBaseDetailsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetryVectorDetail(_response);
        });
    }

    protected processRetryVectorDetail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param fileId (optional) 
     * @param name (optional) 
     * @return Success
     */
    detailsRenameName(fileId: string | undefined, name: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Knowledge/DetailsRenameName?";
        if (fileId === null)
            throw new Error("The parameter 'fileId' cannot be null.");
        else if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDetailsRenameName(_response);
        });
    }

    protected processDetailsRenameName(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param knowledgeBaseId (optional) 
     * @return Success
     */
    checkQuantizationState(knowledgeBaseId: string | undefined): Promise<CheckQuantizationStateDto[]> {
        let url_ = this.baseUrl + "/api/Knowledge/CheckQuantizationState?";
        if (knowledgeBaseId === null)
            throw new Error("The parameter 'knowledgeBaseId' cannot be null.");
        else if (knowledgeBaseId !== undefined)
            url_ += "knowledgeBaseId=" + encodeURIComponent("" + knowledgeBaseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckQuantizationState(_response);
        });
    }

    protected processCheckQuantizationState(response: Response): Promise<CheckQuantizationStateDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckQuantizationStateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckQuantizationStateDto[]>(null as any);
    }
}

export class StorageService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadFile(file: FileParameter | undefined): Promise<UploadFileResult> {
        let url_ = this.baseUrl + "/api/Storage/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<UploadFileResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadFileResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadFileResult>(null as any);
    }

    /**
     * @param path (optional) 
     * @return Success
     */
    uploadWeb(path: string | undefined): Promise<UploadFileResult> {
        let url_ = this.baseUrl + "/api/Storage/UploadWeb?";
        if (path === null)
            throw new Error("The parameter 'path' cannot be null.");
        else if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadWeb(_response);
        });
    }

    protected processUploadWeb(response: Response): Promise<UploadFileResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadFileResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadFileResult>(null as any);
    }

    /**
     * @param path (optional) 
     * @return Success
     */
    uploadData(path: string | undefined): Promise<UploadFileResult> {
        let url_ = this.baseUrl + "/api/Storage/UploadData?";
        if (path === null)
            throw new Error("The parameter 'path' cannot be null.");
        else if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadData(_response);
        });
    }

    protected processUploadData(response: Response): Promise<UploadFileResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadFileResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadFileResult>(null as any);
    }
}

export class UserService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getList(filter: string | undefined, sorting: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/User/GetList?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<UserDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserInput | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeRole(body: ChangeRoleInputDto | undefined): Promise<ResultDto> {
        let url_ = this.baseUrl + "/api/User/ChangeRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeRole(_response);
        });
    }

    protected processChangeRole(response: Response): Promise<ResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInputDto | undefined): Promise<ResultDto> {
        let url_ = this.baseUrl + "/api/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<ResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    disable(body: DisableInputDto | undefined): Promise<ResultDto> {
        let url_ = this.baseUrl + "/api/User/Disable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisable(_response);
        });
    }

    protected processDisable(response: Response): Promise<ResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthorizeDto implements IAuthorizeDto {
    token?: string | undefined;

    constructor(data?: IAuthorizeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AuthorizeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IAuthorizeDto {
    token?: string | undefined;
}

export class ChangePasswordInputDto implements IChangePasswordInputDto {
    password?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInputDto {
    password?: string | undefined;
    newPassword?: string | undefined;
}

export class ChangeRoleInputDto implements IChangeRoleInputDto {
    id?: string;
    role?: RoleType;

    constructor(data?: IChangeRoleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): ChangeRoleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeRoleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["role"] = this.role;
        return data;
    }
}

export interface IChangeRoleInputDto {
    id?: string;
    role?: RoleType;
}

export class ChatApplicationDto implements IChatApplicationDto {
    id?: string;
    name?: string | undefined;
    prompt?: string | undefined;
    chatModel?: string | undefined;
    temperature?: number;
    maxResponseToken?: number;
    template?: string | undefined;
    opener?: string | undefined;
    knowledgeIds?: string[] | undefined;

    constructor(data?: IChatApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.prompt = _data["prompt"];
            this.chatModel = _data["chatModel"];
            this.temperature = _data["temperature"];
            this.maxResponseToken = _data["maxResponseToken"];
            this.template = _data["template"];
            this.opener = _data["opener"];
            if (Array.isArray(_data["knowledgeIds"])) {
                this.knowledgeIds = [] as any;
                for (let item of _data["knowledgeIds"])
                    this.knowledgeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ChatApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["prompt"] = this.prompt;
        data["chatModel"] = this.chatModel;
        data["temperature"] = this.temperature;
        data["maxResponseToken"] = this.maxResponseToken;
        data["template"] = this.template;
        data["opener"] = this.opener;
        if (Array.isArray(this.knowledgeIds)) {
            data["knowledgeIds"] = [];
            for (let item of this.knowledgeIds)
                data["knowledgeIds"].push(item);
        }
        return data;
    }
}

export interface IChatApplicationDto {
    id?: string;
    name?: string | undefined;
    prompt?: string | undefined;
    chatModel?: string | undefined;
    temperature?: number;
    maxResponseToken?: number;
    template?: string | undefined;
    opener?: string | undefined;
    knowledgeIds?: string[] | undefined;
}

export class ChatApplicationDtoPagedResultDto implements IChatApplicationDtoPagedResultDto {
    items?: ChatApplicationDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;

    constructor(data?: IChatApplicationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatApplicationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): ChatApplicationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatApplicationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }
}

export interface IChatApplicationDtoPagedResultDto {
    items?: ChatApplicationDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;
}

export class ChatDialogDto implements IChatDialogDto {
    id?: string;
    name?: string | undefined;
    chatId?: string;
    description?: string | undefined;
    creationTime?: Date;

    constructor(data?: IChatDialogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.chatId = _data["chatId"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatDialogDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatDialogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["chatId"] = this.chatId;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChatDialogDto {
    id?: string;
    name?: string | undefined;
    chatId?: string;
    description?: string | undefined;
    creationTime?: Date;
}

export enum ChatDialogHistoryType {
    _0 = 0,
    _1 = 1,
}

export class CheckQuantizationStateDto implements ICheckQuantizationStateDto {
    state?: KnowledgeBaseQuantizationState;
    knowledgeBaseDetailsId?: string;
    fileName?: string | undefined;

    constructor(data?: ICheckQuantizationStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.knowledgeBaseDetailsId = _data["knowledgeBaseDetailsId"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): CheckQuantizationStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckQuantizationStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["knowledgeBaseDetailsId"] = this.knowledgeBaseDetailsId;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface ICheckQuantizationStateDto {
    state?: KnowledgeBaseQuantizationState;
    knowledgeBaseDetailsId?: string;
    fileName?: string | undefined;
}

export class CreateChatApplicationInputDto implements ICreateChatApplicationInputDto {
    name?: string | undefined;

    constructor(data?: ICreateChatApplicationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateChatApplicationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatApplicationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateChatApplicationInputDto {
    name?: string | undefined;
}

export class CreateChatDialogHistoryInputDto implements ICreateChatDialogHistoryInputDto {
    id?: string;
    chatDialogId?: string;
    content?: string | undefined;
    tokenConsumption?: number;
    type?: ChatDialogHistoryType;

    constructor(data?: ICreateChatDialogHistoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chatDialogId = _data["chatDialogId"];
            this.content = _data["content"];
            this.tokenConsumption = _data["tokenConsumption"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateChatDialogHistoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatDialogHistoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chatDialogId"] = this.chatDialogId;
        data["content"] = this.content;
        data["tokenConsumption"] = this.tokenConsumption;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateChatDialogHistoryInputDto {
    id?: string;
    chatDialogId?: string;
    content?: string | undefined;
    tokenConsumption?: number;
    type?: ChatDialogHistoryType;
}

export class CreateChatDialogHistoryInputDtoPagedResultDto implements ICreateChatDialogHistoryInputDtoPagedResultDto {
    items?: CreateChatDialogHistoryInputDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;

    constructor(data?: ICreateChatDialogHistoryInputDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CreateChatDialogHistoryInputDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): CreateChatDialogHistoryInputDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatDialogHistoryInputDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }
}

export interface ICreateChatDialogHistoryInputDtoPagedResultDto {
    items?: CreateChatDialogHistoryInputDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;
}

export class CreateChatDialogInputDto implements ICreateChatDialogInputDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    applicationId?: string;

    constructor(data?: ICreateChatDialogInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.applicationId = _data["applicationId"];
        }
    }

    static fromJS(data: any): CreateChatDialogInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatDialogInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["applicationId"] = this.applicationId;
        return data;
    }
}

export interface ICreateChatDialogInputDto {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    applicationId?: string;
}

export class CreateKnowledgeBasesInput implements ICreateKnowledgeBasesInput {
    icon?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    embeddingModel?: string | undefined;

    constructor(data?: ICreateKnowledgeBasesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.icon = _data["icon"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.embeddingModel = _data["embeddingModel"];
        }
    }

    static fromJS(data: any): CreateKnowledgeBasesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateKnowledgeBasesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["icon"] = this.icon;
        data["name"] = this.name;
        data["model"] = this.model;
        data["embeddingModel"] = this.embeddingModel;
        return data;
    }
}

export interface ICreateKnowledgeBasesInput {
    icon?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    embeddingModel?: string | undefined;
}

export class CreateKnowledgeDetailsInput implements ICreateKnowledgeDetailsInput {
    fileId?: string;
    filePath?: string | undefined;
    knowledgeId?: string;
    maxTokensPerParagraph?: number;
    maxTokensPerLine?: number;
    overlappingTokens?: number;
    trainingPattern?: TrainingPatternType;
    qaPromptTemplate?: string | undefined;

    constructor(data?: ICreateKnowledgeDetailsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileId = _data["fileId"];
            this.filePath = _data["filePath"];
            this.knowledgeId = _data["knowledgeId"];
            this.maxTokensPerParagraph = _data["maxTokensPerParagraph"];
            this.maxTokensPerLine = _data["maxTokensPerLine"];
            this.overlappingTokens = _data["overlappingTokens"];
            this.trainingPattern = _data["trainingPattern"];
            this.qaPromptTemplate = _data["qaPromptTemplate"];
        }
    }

    static fromJS(data: any): CreateKnowledgeDetailsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateKnowledgeDetailsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileId"] = this.fileId;
        data["filePath"] = this.filePath;
        data["knowledgeId"] = this.knowledgeId;
        data["maxTokensPerParagraph"] = this.maxTokensPerParagraph;
        data["maxTokensPerLine"] = this.maxTokensPerLine;
        data["overlappingTokens"] = this.overlappingTokens;
        data["trainingPattern"] = this.trainingPattern;
        data["qaPromptTemplate"] = this.qaPromptTemplate;
        return data;
    }
}

export interface ICreateKnowledgeDetailsInput {
    fileId?: string;
    filePath?: string | undefined;
    knowledgeId?: string;
    maxTokensPerParagraph?: number;
    maxTokensPerLine?: number;
    overlappingTokens?: number;
    trainingPattern?: TrainingPatternType;
    qaPromptTemplate?: string | undefined;
}

export class CreatePostShareInput implements ICreatePostShareInput {
    name?: string | undefined;
    chatApplicationId?: string | undefined;
    expires?: Date;
    availableToken?: number;
    availableQuantity?: number;

    constructor(data?: ICreatePostShareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.chatApplicationId = _data["chatApplicationId"];
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            this.availableToken = _data["availableToken"];
            this.availableQuantity = _data["availableQuantity"];
        }
    }

    static fromJS(data: any): CreatePostShareInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePostShareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["chatApplicationId"] = this.chatApplicationId;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["availableToken"] = this.availableToken;
        data["availableQuantity"] = this.availableQuantity;
        return data;
    }
}

export interface ICreatePostShareInput {
    name?: string | undefined;
    chatApplicationId?: string | undefined;
    expires?: Date;
    availableToken?: number;
    availableQuantity?: number;
}

export class CreateUserInput implements ICreateUserInput {
    account?: string | undefined;
    name?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;

    constructor(data?: ICreateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.name = _data["name"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): CreateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["name"] = this.name;
        data["password"] = this.password;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface ICreateUserInput {
    account?: string | undefined;
    name?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
}

export class DisableInputDto implements IDisableInputDto {
    id?: string;
    disable?: boolean;

    constructor(data?: IDisableInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.disable = _data["disable"];
        }
    }

    static fromJS(data: any): DisableInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisableInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["disable"] = this.disable;
        return data;
    }
}

export interface IDisableInputDto {
    id?: string;
    disable?: boolean;
}

export class FastWikiFunctionCallInput implements IFastWikiFunctionCallInput {
    name?: string | undefined;
    description?: string | undefined;
    content?: string | undefined;
    parameters?: FunctionItemDto[] | undefined;
    items?: FunctionItemDto[] | undefined;
    imports?: string[] | undefined;
    main?: string | undefined;

    constructor(data?: IFastWikiFunctionCallInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.content = _data["content"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(FunctionItemDto.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FunctionItemDto.fromJS(item));
            }
            if (Array.isArray(_data["imports"])) {
                this.imports = [] as any;
                for (let item of _data["imports"])
                    this.imports!.push(item);
            }
            this.main = _data["main"];
        }
    }

    static fromJS(data: any): FastWikiFunctionCallInput {
        data = typeof data === 'object' ? data : {};
        let result = new FastWikiFunctionCallInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["content"] = this.content;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.imports)) {
            data["imports"] = [];
            for (let item of this.imports)
                data["imports"].push(item);
        }
        data["main"] = this.main;
        return data;
    }
}

export interface IFastWikiFunctionCallInput {
    name?: string | undefined;
    description?: string | undefined;
    content?: string | undefined;
    parameters?: FunctionItemDto[] | undefined;
    items?: FunctionItemDto[] | undefined;
    imports?: string[] | undefined;
    main?: string | undefined;
}

export class FileStorage implements IFileStorage {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deletionTime?: Date | undefined;
    deleterUserId?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    size?: number;
    isCompression?: boolean;
    fullName?: string | undefined;
    type?: string | undefined;

    constructor(data?: IFileStorage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.size = _data["size"];
            this.isCompression = _data["isCompression"];
            this.fullName = _data["fullName"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): FileStorage {
        data = typeof data === 'object' ? data : {};
        let result = new FileStorage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["name"] = this.name;
        data["path"] = this.path;
        data["size"] = this.size;
        data["isCompression"] = this.isCompression;
        data["fullName"] = this.fullName;
        data["type"] = this.type;
        return data;
    }
}

export interface IFileStorage {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deletionTime?: Date | undefined;
    deleterUserId?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    size?: number;
    isCompression?: boolean;
    fullName?: string | undefined;
    type?: string | undefined;
}

export class FunctionItemDto implements IFunctionItemDto {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IFunctionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FunctionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new FunctionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IFunctionItemDto {
    key?: string | undefined;
    value?: string | undefined;
}

export class KnowledgeBase implements IKnowledgeBase {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deletionTime?: Date | undefined;
    deleterUserId?: string | undefined;
    icon?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    embeddingModel?: string | undefined;
    knowledgeBaseDetails?: KnowledgeBaseDetails[] | undefined;

    constructor(data?: IKnowledgeBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.icon = _data["icon"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.embeddingModel = _data["embeddingModel"];
            if (Array.isArray(_data["knowledgeBaseDetails"])) {
                this.knowledgeBaseDetails = [] as any;
                for (let item of _data["knowledgeBaseDetails"])
                    this.knowledgeBaseDetails!.push(KnowledgeBaseDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): KnowledgeBase {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["icon"] = this.icon;
        data["name"] = this.name;
        data["model"] = this.model;
        data["embeddingModel"] = this.embeddingModel;
        if (Array.isArray(this.knowledgeBaseDetails)) {
            data["knowledgeBaseDetails"] = [];
            for (let item of this.knowledgeBaseDetails)
                data["knowledgeBaseDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IKnowledgeBase {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deletionTime?: Date | undefined;
    deleterUserId?: string | undefined;
    icon?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    embeddingModel?: string | undefined;
    knowledgeBaseDetails?: KnowledgeBaseDetails[] | undefined;
}

export class KnowledgeBaseDetailVectorQuantityDto implements IKnowledgeBaseDetailVectorQuantityDto {
    index?: number;
    id?: string | undefined;
    content?: string | undefined;
    document_Id?: string | undefined;
    wikiDetailId?: string | undefined;
    fileId?: string | undefined;

    constructor(data?: IKnowledgeBaseDetailVectorQuantityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.id = _data["id"];
            this.content = _data["content"];
            this.document_Id = _data["document_Id"];
            this.wikiDetailId = _data["wikiDetailId"];
            this.fileId = _data["fileId"];
        }
    }

    static fromJS(data: any): KnowledgeBaseDetailVectorQuantityDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseDetailVectorQuantityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["id"] = this.id;
        data["content"] = this.content;
        data["document_Id"] = this.document_Id;
        data["wikiDetailId"] = this.wikiDetailId;
        data["fileId"] = this.fileId;
        return data;
    }
}

export interface IKnowledgeBaseDetailVectorQuantityDto {
    index?: number;
    id?: string | undefined;
    content?: string | undefined;
    document_Id?: string | undefined;
    wikiDetailId?: string | undefined;
    fileId?: string | undefined;
}

export class KnowledgeBaseDetailVectorQuantityDtoPagedResultDto implements IKnowledgeBaseDetailVectorQuantityDtoPagedResultDto {
    items?: KnowledgeBaseDetailVectorQuantityDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;

    constructor(data?: IKnowledgeBaseDetailVectorQuantityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KnowledgeBaseDetailVectorQuantityDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): KnowledgeBaseDetailVectorQuantityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseDetailVectorQuantityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }
}

export interface IKnowledgeBaseDetailVectorQuantityDtoPagedResultDto {
    items?: KnowledgeBaseDetailVectorQuantityDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;
}

export class KnowledgeBaseDetails implements IKnowledgeBaseDetails {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deletionTime?: Date | undefined;
    deleterUserId?: string | undefined;
    state?: KnowledgeBaseQuantizationState;
    maxTokensPerParagraph?: number;
    maxTokensPerLine?: number;
    overlappingTokens?: number;
    trainingPattern?: TrainingPatternType;
    qaPromptTemplate?: string | undefined;
    file?: FileStorage;
    dataCount?: number;
    knowledgeBase?: KnowledgeBase;

    constructor(data?: IKnowledgeBaseDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.deleterUserId = _data["deleterUserId"];
            this.state = _data["state"];
            this.maxTokensPerParagraph = _data["maxTokensPerParagraph"];
            this.maxTokensPerLine = _data["maxTokensPerLine"];
            this.overlappingTokens = _data["overlappingTokens"];
            this.trainingPattern = _data["trainingPattern"];
            this.qaPromptTemplate = _data["qaPromptTemplate"];
            this.file = _data["file"] ? FileStorage.fromJS(_data["file"]) : <any>undefined;
            this.dataCount = _data["dataCount"];
            this.knowledgeBase = _data["knowledgeBase"] ? KnowledgeBase.fromJS(_data["knowledgeBase"]) : <any>undefined;
        }
    }

    static fromJS(data: any): KnowledgeBaseDetails {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["state"] = this.state;
        data["maxTokensPerParagraph"] = this.maxTokensPerParagraph;
        data["maxTokensPerLine"] = this.maxTokensPerLine;
        data["overlappingTokens"] = this.overlappingTokens;
        data["trainingPattern"] = this.trainingPattern;
        data["qaPromptTemplate"] = this.qaPromptTemplate;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        data["dataCount"] = this.dataCount;
        data["knowledgeBase"] = this.knowledgeBase ? this.knowledgeBase.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKnowledgeBaseDetails {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deletionTime?: Date | undefined;
    deleterUserId?: string | undefined;
    state?: KnowledgeBaseQuantizationState;
    maxTokensPerParagraph?: number;
    maxTokensPerLine?: number;
    overlappingTokens?: number;
    trainingPattern?: TrainingPatternType;
    qaPromptTemplate?: string | undefined;
    file?: FileStorage;
    dataCount?: number;
    knowledgeBase?: KnowledgeBase;
}

export class KnowledgeBaseDetailsDto implements IKnowledgeBaseDetailsDto {
    state?: KnowledgeBaseQuantizationState;
    maxTokensPerParagraph?: number;
    maxTokensPerLine?: number;
    overlappingTokens?: number;
    trainingPattern?: TrainingPatternType;
    qaPromptTemplate?: string | undefined;
    dataCount?: number;
    file?: FileStorage;
    knowledgeBase?: KnowledgeBase;
    lastModifierId?: string;
    lastModificationTime?: Date | undefined;

    constructor(data?: IKnowledgeBaseDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.maxTokensPerParagraph = _data["maxTokensPerParagraph"];
            this.maxTokensPerLine = _data["maxTokensPerLine"];
            this.overlappingTokens = _data["overlappingTokens"];
            this.trainingPattern = _data["trainingPattern"];
            this.qaPromptTemplate = _data["qaPromptTemplate"];
            this.dataCount = _data["dataCount"];
            this.file = _data["file"] ? FileStorage.fromJS(_data["file"]) : <any>undefined;
            this.knowledgeBase = _data["knowledgeBase"] ? KnowledgeBase.fromJS(_data["knowledgeBase"]) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): KnowledgeBaseDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["maxTokensPerParagraph"] = this.maxTokensPerParagraph;
        data["maxTokensPerLine"] = this.maxTokensPerLine;
        data["overlappingTokens"] = this.overlappingTokens;
        data["trainingPattern"] = this.trainingPattern;
        data["qaPromptTemplate"] = this.qaPromptTemplate;
        data["dataCount"] = this.dataCount;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        data["knowledgeBase"] = this.knowledgeBase ? this.knowledgeBase.toJSON() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IKnowledgeBaseDetailsDto {
    state?: KnowledgeBaseQuantizationState;
    maxTokensPerParagraph?: number;
    maxTokensPerLine?: number;
    overlappingTokens?: number;
    trainingPattern?: TrainingPatternType;
    qaPromptTemplate?: string | undefined;
    dataCount?: number;
    file?: FileStorage;
    knowledgeBase?: KnowledgeBase;
    lastModifierId?: string;
    lastModificationTime?: Date | undefined;
}

export class KnowledgeBaseDetailsDtoPagedResultDto implements IKnowledgeBaseDetailsDtoPagedResultDto {
    items?: KnowledgeBaseDetailsDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;

    constructor(data?: IKnowledgeBaseDetailsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KnowledgeBaseDetailsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): KnowledgeBaseDetailsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseDetailsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }
}

export interface IKnowledgeBaseDetailsDtoPagedResultDto {
    items?: KnowledgeBaseDetailsDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;
}

export class KnowledgeBaseDetailsVectorQuantityInputDto implements IKnowledgeBaseDetailsVectorQuantityInputDto {
    filter?: string | undefined;
    sorting?: string | undefined;
    pageNumber?: number;
    pageSize?: number;
    knowledgeBaseDetailsId?: string;

    constructor(data?: IKnowledgeBaseDetailsVectorQuantityInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.knowledgeBaseDetailsId = _data["knowledgeBaseDetailsId"];
        }
    }

    static fromJS(data: any): KnowledgeBaseDetailsVectorQuantityInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseDetailsVectorQuantityInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["knowledgeBaseDetailsId"] = this.knowledgeBaseDetailsId;
        return data;
    }
}

export interface IKnowledgeBaseDetailsVectorQuantityInputDto {
    filter?: string | undefined;
    sorting?: string | undefined;
    pageNumber?: number;
    pageSize?: number;
    knowledgeBaseDetailsId?: string;
}

export enum KnowledgeBaseQuantizationState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class KnowledgeBasesDto implements IKnowledgeBasesDto {
    id?: string;
    icon?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    embeddingModel?: string | undefined;

    constructor(data?: IKnowledgeBasesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.icon = _data["icon"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.embeddingModel = _data["embeddingModel"];
        }
    }

    static fromJS(data: any): KnowledgeBasesDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBasesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["icon"] = this.icon;
        data["name"] = this.name;
        data["model"] = this.model;
        data["embeddingModel"] = this.embeddingModel;
        return data;
    }
}

export interface IKnowledgeBasesDto {
    id?: string;
    icon?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    embeddingModel?: string | undefined;
}

export class KnowledgeBasesDtoPagedResultDto implements IKnowledgeBasesDtoPagedResultDto {
    items?: KnowledgeBasesDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;

    constructor(data?: IKnowledgeBasesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KnowledgeBasesDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): KnowledgeBasesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBasesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }
}

export interface IKnowledgeBasesDtoPagedResultDto {
    items?: KnowledgeBasesDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;
}

export class PostShareDto implements IPostShareDto {
    id?: string | undefined;
    name?: string | undefined;
    chatApplicationId?: string | undefined;
    expires?: Date | undefined;
    usedToken?: number;
    availableToken?: number;
    availableQuantity?: number;
    apiKey?: string | undefined;

    constructor(data?: IPostShareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.chatApplicationId = _data["chatApplicationId"];
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            this.usedToken = _data["usedToken"];
            this.availableToken = _data["availableToken"];
            this.availableQuantity = _data["availableQuantity"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): PostShareDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostShareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["chatApplicationId"] = this.chatApplicationId;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["usedToken"] = this.usedToken;
        data["availableToken"] = this.availableToken;
        data["availableQuantity"] = this.availableQuantity;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IPostShareDto {
    id?: string | undefined;
    name?: string | undefined;
    chatApplicationId?: string | undefined;
    expires?: Date | undefined;
    usedToken?: number;
    availableToken?: number;
    availableQuantity?: number;
    apiKey?: string | undefined;
}

export class PostShareDtoPagedResultDto implements IPostShareDtoPagedResultDto {
    items?: PostShareDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;

    constructor(data?: IPostShareDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PostShareDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): PostShareDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostShareDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }
}

export interface IPostShareDtoPagedResultDto {
    items?: PostShareDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;
}

export class ResultDto implements IResultDto {
    code?: string | undefined;
    message?: string | undefined;
    data?: any | undefined;

    constructor(data?: IResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IResultDto {
    code?: string | undefined;
    message?: string | undefined;
    data?: any | undefined;
}

export enum RoleType {
    _0 = 0,
    _1 = 1,
}

export class SearchVectorQuantity implements ISearchVectorQuantity {
    content?: string | undefined;
    fullPath?: string | undefined;
    fileName?: string | undefined;
    relevance?: number;
    documentId?: string | undefined;
    fileId?: string | undefined;

    constructor(data?: ISearchVectorQuantity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.fullPath = _data["fullPath"];
            this.fileName = _data["fileName"];
            this.relevance = _data["relevance"];
            this.documentId = _data["documentId"];
            this.fileId = _data["fileId"];
        }
    }

    static fromJS(data: any): SearchVectorQuantity {
        data = typeof data === 'object' ? data : {};
        let result = new SearchVectorQuantity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["fullPath"] = this.fullPath;
        data["fileName"] = this.fileName;
        data["relevance"] = this.relevance;
        data["documentId"] = this.documentId;
        data["fileId"] = this.fileId;
        return data;
    }
}

export interface ISearchVectorQuantity {
    content?: string | undefined;
    fullPath?: string | undefined;
    fileName?: string | undefined;
    relevance?: number;
    documentId?: string | undefined;
    fileId?: string | undefined;
}

export class SearchVectorQuantityDto implements ISearchVectorQuantityDto {
    elapsedTime?: number;
    result?: SearchVectorQuantity[] | undefined;

    constructor(data?: ISearchVectorQuantityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.elapsedTime = _data["elapsedTime"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SearchVectorQuantity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchVectorQuantityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchVectorQuantityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elapsedTime"] = this.elapsedTime;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchVectorQuantityDto {
    elapsedTime?: number;
    result?: SearchVectorQuantity[] | undefined;
}

export enum TrainingPatternType {
    _0 = 0,
    _1 = 1,
}

export class UpdateChatApplicationInputDto implements IUpdateChatApplicationInputDto {
    id?: string;
    name?: string | undefined;
    prompt?: string | undefined;
    chatModel?: string | undefined;
    temperature?: number;
    maxResponseToken?: number;
    template?: string | undefined;
    opener?: string | undefined;
    knowledgeIds?: string[] | undefined;

    constructor(data?: IUpdateChatApplicationInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.prompt = _data["prompt"];
            this.chatModel = _data["chatModel"];
            this.temperature = _data["temperature"];
            this.maxResponseToken = _data["maxResponseToken"];
            this.template = _data["template"];
            this.opener = _data["opener"];
            if (Array.isArray(_data["knowledgeIds"])) {
                this.knowledgeIds = [] as any;
                for (let item of _data["knowledgeIds"])
                    this.knowledgeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateChatApplicationInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChatApplicationInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["prompt"] = this.prompt;
        data["chatModel"] = this.chatModel;
        data["temperature"] = this.temperature;
        data["maxResponseToken"] = this.maxResponseToken;
        data["template"] = this.template;
        data["opener"] = this.opener;
        if (Array.isArray(this.knowledgeIds)) {
            data["knowledgeIds"] = [];
            for (let item of this.knowledgeIds)
                data["knowledgeIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateChatApplicationInputDto {
    id?: string;
    name?: string | undefined;
    prompt?: string | undefined;
    chatModel?: string | undefined;
    temperature?: number;
    maxResponseToken?: number;
    template?: string | undefined;
    opener?: string | undefined;
    knowledgeIds?: string[] | undefined;
}

export class UpdateKnowledgeBasesInput implements IUpdateKnowledgeBasesInput {
    id?: string;
    icon?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    embeddingModel?: string | undefined;

    constructor(data?: IUpdateKnowledgeBasesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.icon = _data["icon"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.embeddingModel = _data["embeddingModel"];
        }
    }

    static fromJS(data: any): UpdateKnowledgeBasesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateKnowledgeBasesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["icon"] = this.icon;
        data["name"] = this.name;
        data["model"] = this.model;
        data["embeddingModel"] = this.embeddingModel;
        return data;
    }
}

export interface IUpdateKnowledgeBasesInput {
    id?: string;
    icon?: string | undefined;
    name?: string | undefined;
    model?: string | undefined;
    embeddingModel?: string | undefined;
}

export class UploadFileResult implements IUploadFileResult {
    path?: string | undefined;
    id?: string;

    constructor(data?: IUploadFileResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UploadFileResult {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["id"] = this.id;
        return data;
    }
}

export interface IUploadFileResult {
    path?: string | undefined;
    id?: string;
}

export class UserDto implements IUserDto {
    id?: string;
    account?: string | undefined;
    name?: string | undefined;
    password?: string | undefined;
    salt?: string | undefined;
    avatar?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    isDisable?: boolean;
    role?: RoleType;
    readonly roleName?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.account = _data["account"];
            this.name = _data["name"];
            this.password = _data["password"];
            this.salt = _data["salt"];
            this.avatar = _data["avatar"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.isDisable = _data["isDisable"];
            this.role = _data["role"];
            (<any>this).roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["account"] = this.account;
        data["name"] = this.name;
        data["password"] = this.password;
        data["salt"] = this.salt;
        data["avatar"] = this.avatar;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["isDisable"] = this.isDisable;
        data["role"] = this.role;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserDto {
    id?: string;
    account?: string | undefined;
    name?: string | undefined;
    password?: string | undefined;
    salt?: string | undefined;
    avatar?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    isDisable?: boolean;
    role?: RoleType;
    roleName?: string | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items?: UserDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }
}

export interface IUserDtoPagedResultDto {
    items?: UserDto[] | undefined;
    totalCount?: number;
    pageSize?: number;
    pageNumber?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}